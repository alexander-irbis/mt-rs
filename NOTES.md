
# Задача

Контейнер Merkle Tree с прагматичным, гибким и универсальным интерфейсом.

Эффективный и при этом читаемый код.

Документация, тесты, бенчмарки.


# Резюме

Текущая реализация - в первую очередь прототип, демонстрирующий возможности и сильные/слабые 
стороны подхода, перед которым не ставилась цель завершённое решение, пригодное для использования
в продакшене. Ряд вопросов, касающихся области применения библиотеки, необходимой в ней 
функциональности, остался открытым.

Более того, часть функций требуют серьёзной проработки и за те несколько дней, что были выделены
на разработку прототипа и без всестороннего обсуждения, не могут быть решены.

В текущем виде библиотека состоит из необходимых базовых интерфейсов и примеров их реализации.

Тем не менее, код писался с расчётом, что библиотека может получить дальнейшее развитие и 
практическое применение.


# Реализация

Основной элемент библиотеки, с которым предстоит работать пользователю - экземпляр MerkleTree -
можно разделить на два условно независимых компонента - дерево хешей, необходимое для
контроля целостности данных, и, собственно сами данные, для которых оно строится. Для обеих частей
необходима возможность иметь различные реализации бэкендов, обеспечивающие хранение данных, которые,
при этом, должны поддерживаться в синхронном состоянии. Также в различных реализациях блокчейнов
(и систем верификации контента в более широком смысле) применяется достаточно большое множество
различных алгоритмов хеширования, эта сфера активно развивается, в связи с чем на выбор алгоритма
подтверждения целостности так же должен накладываться минимум ограничений.


Универсальность реализаций достигается за счёт обобщения вокруг нескольких базовых интерфейсов:


`MTAlgorithm` - этот типаж служит интерфейсом для алгоритмов хеширования.
    Он связывает алгоритм с типом, хранящим значение и типом, выполняющим само хеширование.

`MTHash` - реализуется для структур, предоставляющих данные для хеширования

Поскольку мы строим дерево подтверждения, этот типаж должен реализовываться и для структур, 
    хранящих хеши.

`MTContext` - реализуется для структур, хранящих состояние в процессе обработки данных, 
    и выполняющих непосредственно хеширование.

`DataStorageReadonly` - базовый типаж для хранилищ данных, предоставляющий только интерфейс 
    доступа к данным

`DataStorage` - дополняет его методами записи.
    Подобное разделение позволяет отделить статически на уровне типов источники данных, которые
    не должны модифицироваться. Например, это может быть полезно для архивов.

Отдельно предполагается полезным ограничивать возможность записи во время выполнения,
    например, в ситуации, когда данные могут находиться на недоступном для записи носителе или у 
    пользователя нет соответствующих прав на запись, но сама возможность записи в других ситуациях
    должна присутствовать.

`TreeStorage` - выполняет аналогичную функцию для хранилищ данных деревьев.

    В данный момент предусмотрена только возможность добавления данных в конец коллекции.
    Так же легко (но нужно ли это кому-то?) можно реализовать замену отдельной записи в коллекции.

    Вставка или удаление элементов коллекции потребует перестроения значительной части дерева,
    тем больше, чем дальше от конца будет эта модификация. Если это необходимо, возможно, имеет
    смысл реализовать такую функциональность, поскольку часть дерева может быть перестроена быстрее,
    чем целое и для небольших коллекций с быстрой функцией хеширования это будет работать за 
    приемлемое время. Но для больших коллекций имеет смысл все подобные модификации группировать
    и полностью перестраивать дерево.

    

Конечный экземпляр MerkleTree, с которым будет работать пользователь, собирается как конструктор 
из необходимых типов, реализующих соответствующие типажи. В тестах можно увидеть такой пример:

```rust
MerkleTree<MemoryDataStorage<&'static [u8]>, MemoryTreeStorage<DoubleHash<Sha256>>>
```

Здесь в качестве бэкендов выбраны хранилища в памяти, тип данных, попадающий в хранилище данных, - 
статическая ссылка на байтовый слайс, а хеширующая функция - dhash(sha256), принятый для 
подтверждения транзакций в блокчейне Биткойна. 

`DoubleHash` при этом - сервисный тип-обёртка, в который можно обернуть любую другую функцию.


# Что осталось за рамками

По примеру `DoubleHash` возможно реализовать аналогичные обёртки, например, вокруг кортежей и любых
других более сложных структурно типов, совместив в одном типе несколько хеширующих функций и их
последовательности (например, построив от исходных данных хеши по функциям `a` и `b`, а затем
производный от них хеш по функции `c`).

Таким же образом можно реализовать различные сервисные обёртки над данными, которые будут 
каким-либо образом нормализовать данные перед хешированием, например, приводить строки к нижнему
регистру, единому юникодному представлению, сериализовать объекты и т.п., причём некоторые из 
подобных преобразований вполне можно осуществлять буферизованно, без выделения памяти под крупные
структуры.

Точно так же вместо бэкендов, хранящих данные в памяти (самый простой и быстроработающий, но не 
самый универсальный подход), можно по примеру реализовать бэкенды, хранящие данные в файлах или 
в базе данных.

При этом библиотека не берёт на себя комплексно задачу по сериализации данных в хранилище, их 
сохранению на диск и чтению обратно в память. Эти задачи невозможно универсально решить для 
бэкендов, которые могут иметь собственное состояние, не зависящее от сохраняемых данных (например,
соединение с базой данных). В свою очередь это обязанность реализации бэкенда обеспечить 
соответствующие механизмы.

Это должно быть достаточно несложно реализуемо, для чего бэкенду достаточно наложить соответствующие
ограничения на хранимые данные, например, в виде типажей `Serializable` / `Deserializable` из 
`serde` или `ToSql` / `FromSql` от соответствующего драйвера базы данных.


# Эволюция решения

Библиотека изначально планировалась как максимально универсальная и расширяемая. Однако реализация
шла по пути от простого к сложному - сначала получение минимально работающего прототипа, а затем
добавление новых уровней абстракции.

По пути пришлось столкнуться с растущим уровнем сложности интерфейсов. Например, изначально 
предполагалась "щадящая" обработка ошибок выхода за границы диапазона, типичная для стандартной
библиотеки, при которой функции доступа возвращают значение опционально. Однако необходимость 
учитывать, что операции с устройствами ввода-вывода или транзакции в базе данных могут завершаться
ошибками, и отражение этой особенности в интерфейсе привела к появлению достаточно монстрообразных
сигнатур у отдельных методов.

```rust
fn get_level_len(&self, level: usize) -> Result<Option<usize>>;

fn get_value(&self, level: usize, index: usize) -> Result<Option<<Self::Algorithm as MTAlgorithm>::Value>>;

fn iter_level_by_pair<'s>(&'s self, level: usize) -> Result<Option<Box<Iterator<
    Item=Result<(<Self::Algorithm as MTAlgorithm>::Value, <Self::Algorithm as MTAlgorithm>::Value)>
> + 's>>>;
```

Помимо того, что это сильно усложняло понимание того, как работают эти методы, ещё большее 
воздействие это оказало на эргономику, требуя писать достаточно сложные выражения для доступа 
к данным. При этом само использование этих интерфейсов в значительной мере сконцентрировано
в MerkleTree в ситуациях, когда проверка на выход за пределы диапазона уже произведена и реальный
выход за границы диапазона - это на самом деле ошибка алгоритма, а не элемент удобства пользователя,
упрощающий проверку и выполнение действий в связи с "промахом".

Поэтому было принято решение превратить выход за границы диапазона в полноценную ошибку, что сильно
упростило и интерфейс и код работы с данными.
А следом был обнаружен интересный паттерн - по аналогии с возможностью превратить ошибку в опцию,
как это сделано в стандартной библиотеке - `Result::ok()`, возможно превратить в опцию селективно
конкретный вид ошибок - `MTResultExt::iob_is_ok()`. Подобный подход оказался весьма выразителен в
сочетании с оператором `?`. При этом подобные "прощения" ошибок легко комбинировать.


# Забавные моменты

В процессе эволюции кода произошла одна интересная метаморфоза, когда простой с виду цикл, 
```rust
for (block, cs) in self.data.iter().zip(self.tree.iter_level(0)) {
    let hash = T::Algorithm::eval_hash(block);
    if hash != *cs {
        return Err(CheckError::DataDoesNotMatchTheChecksum);
    }
}
```

Был заменён на не менее простое итераторное выражение, которое более наглядно отражало смысл кода.
```rust
if self.data.iter()
    .map(|block| T::Algorithm::eval_hash(block))
    .zip(self.tree.iter_level(0))
    .any(|(hash, cs)| hash != *cs)
{
    return Err(CheckError::DataDoesNotMatchTheChecksum);
}
```

Однако в процессе усложнения системы типов оно также начало усложняться
```rust
if self.data.iter()
    .zip(self.tree.iter_level(0).unwrap())
    .map(|(block, cs)| block.map(|block| T::Algorithm::eval_hash(&block)).map(|hash| hash != *cs))
    .fold(Ok(false), |acc, item| acc.and_then(|acc| item.map(|item| acc || item)) )?
{
    Err(StateError::DataDoesNotMatchTheChecksum)?;
}
```

```rust
if self.data.iter()?
    .zip(self.tree.iter_level(0)?.unwrap())
    .map(|(block, cs)| block
        .map(|block| T::Algorithm::eval_hash(&block))
        .and_then(|hash| cs.map(|cs| (hash, cs)))
        .map(|(hash, cs)| hash != cs)
    )
    .fold(Ok(false), |acc, item| acc.and_then(|acc| item.map(|item| acc || item)) )?
{
    Err(StateError::DataDoesNotMatchTheChecksum)?;
}
```

После чего попытка всё упростить
```rust
if self.data.iter()?
    .zip(self.tree.iter_level(0)?.unwrap())
    .map(|(block, cs)| { Ok(T::Algorithm::eval_hash(&block?) != cs?) })
    .fold(Ok(false), |acc: Result<_>, item: Result<_>| Ok(acc? || item?) )?
{
    Err(StateError::DataDoesNotMatchTheChecksum)?;
}
```

Логически замкнула круг
```rust
for (block, cs) in self.data.iter()?.zip(self.tree.iter_level(0)?) {
    if T::Algorithm::eval_hash(&block?) != cs? {
        Err(StateError::DataDoesNotMatchTheChecksum)?;
    }
}
```


# Производительность

В процессе обобщения кода пришлось пойти на некоторые жертвы, например, отказаться от ссылок на хеши
и блоки данных в пользу клонируемых значений. Чтобы понять, чем мы на самом деле пожертвовали, была
восстановлена копия типа MerkleTree - MerkleTreeSimple, похожая на то, что было в начале разработки - 
монолитное хранилище в памяти, обращающееся к данным и хешам по ссылке, а не к копии.

Также ради контроля была замерена отдельно производительность с доступным только на чтение 
хранилищем, но здесь совершенно не ожидалось каких-то специфичных результатов. Скорее это тест
на будущее, если что-то серьёзно поменяется в архитектуре.

Результаты того, насколько в данном случае это всё влияет на производительность, можно увидеть
запустив бенчмарк `generic_vs_simple`. 

Первые тестирвоания производительности происходили с ошибкой в алгоритме поэлементного добавления
записей в коллекцию, из-за чего сильно страдала производительность. Был сделан вывод о необходимости
реализовать компромиссный режим заполнения коллекции блоками. В процессе реализации этого режима
ошибка и была обнаружена и исправлена, и выводы об ухудшении производительности в поэлементном 
методе наполнения теперь далеко не такие мрачные. А у нас теперь есть ещё один метод для 
тестирвоания и изучения возможностей.


`bulk` - коллекция создаётся раздельно, сначала наполняется данными, потом строится дерево.

`step_by_step` - коллекция наполняется по одной записи, после чего дерево обновляется.

`step_bulk` - компромисное решение с обновлением блоками.

`n1e5` - количество элементов - 10^5.

В качестве записи используется массив 4кб, воспроизводимо заполненный числовым генератором.

Первое, что было интересно - во сколько же нам на самом деле обходится абстракция.

```
test sha256::n1e3::x_4096::bulk_generic                   ... bench:   2,214,431 ns/iter (+/- 83,395)
test sha256::n1e3::x_4096::bulk_simple                    ... bench:   2,171,275 ns/iter (+/- 45,108)
                                                    generic / simple = 1.019_87587938

test sha256::n1e4::x_4096::bulk_generic                   ... bench:  25,043,463 ns/iter (+/- 487,929)
test sha256::n1e4::x_4096::bulk_simple                    ... bench:  24,673,562 ns/iter (+/- 578,932)
                                                    generic / simple = 1.014_99179567

test sha256::n1e5::x_4096::bulk_generic                   ... bench: 252,816,195 ns/iter (+/- 3,814,964)
test sha256::n1e5::x_4096::bulk_simple                    ... bench: 249,623,110 ns/iter (+/- 2,855,011)
                                                    generic / simple = 1.012_79162414


test sha256::n1e3::x_4096::step_by_step_generic           ... bench:   2,723,182 ns/iter (+/- 62,378)
test sha256::n1e3::x_4096::step_by_step_simple            ... bench:   2,631,601 ns/iter (+/- 63,605)
                                                    generic / simple = 1.034_80048837

test sha256::n1e4::x_4096::step_by_step_generic           ... bench:  33,549,741 ns/iter (+/- 515,582)
test sha256::n1e4::x_4096::step_by_step_simple            ... bench:  32,425,546 ns/iter (+/- 411,461)
                                                    generic / simple = 1.034_67004071

test sha256::n1e5::x_4096::step_by_step_generic           ... bench: 358,348,106 ns/iter (+/- 1,015,735)
test sha256::n1e5::x_4096::step_by_step_simple            ... bench: 345,182,582 ns/iter (+/- 803,091)
                                                    generic / simple = 1.038_14075416
```

Можно заметить, что на данном диапазоне значений (до 10 тыс. элементов в коллекции) и с функцией
sha256 заметного выигрыша получить не удаётся. Однако с другими функциями результат может 
существенно отличаться.

```
test rust_siphash::n1e4::x_4096::bulk_generic             ... bench:   5,312,742 ns/iter (+/- 535,085)
test rust_siphash::n1e4::x_4096::bulk_simple              ... bench:   4,683,927 ns/iter (+/- 356,087)
                                                    generic / simple = 1.134_24953036

test rust_siphash::n1e4::x_4096::step_by_step_generic     ... bench:   7,204,209 ns/iter (+/- 304,100)
test rust_siphash::n1e4::x_4096::step_by_step_simple      ... bench:   6,632,643 ns/iter (+/- 213,190)
                                                    generic / simple = 1.086_17469687

test crc32::n1e4::x_4096::bulk_generic                    ... bench:  22,722,848 ns/iter (+/- 711,039)
test crc32::n1e4::x_4096::bulk_simple                     ... bench:  19,732,006 ns/iter (+/- 521,278)
                                                    generic / simple = 1.151_57313453

test crc32::n1e4::x_4096::step_by_step_generic            ... bench:  56,176,490 ns/iter (+/- 794,856)
test crc32::n1e4::x_4096::step_by_step_simple             ... bench:  54,829,636 ns/iter (+/- 747,486)
                                                    generic / simple = 1.024_56434327
```

Другой предмет интереса - компромиссный метод добавления данных в коллекцию порциями.

```
test sha256::n1e5::x_4096::bulk_generic                   ... bench: 252,816,195 ns/iter (+/- 3,814,964)
test sha256::n1e5::x_4096::bulk_simple                    ... bench: 249,623,110 ns/iter (+/- 2,855,011)

test sha256::n1e5::x_4096::step_bulk::x1e4::generic       ... bench: 292,691,592 ns/iter (+/- 1,791,851)
test sha256::n1e5::x_4096::step_bulk::x1e4::simple        ... bench: 252,173,157 ns/iter (+/- 1,178,176)

test sha256::n1e5::x_4096::step_bulk::x1e3::generic       ... bench: 302,048,260 ns/iter (+/- 974,527)
test sha256::n1e5::x_4096::step_bulk::x1e3::simple        ... bench: 249,206,804 ns/iter (+/- 1,241,156)

test sha256::n1e5::x_4096::step_bulk::x1e2::generic       ... bench: 440,450,072 ns/iter (+/- 1,735,211)
test sha256::n1e5::x_4096::step_bulk::x1e2::simple        ... bench: 256,471,394 ns/iter (+/- 1,038,351)

test sha256::n1e5::x_4096::step_bulk::x1e1::generic       ... bench: 404,346,976 ns/iter (+/- 930,499)
test sha256::n1e5::x_4096::step_bulk::x1e1::simple        ... bench: 346,379,579 ns/iter (+/- 762,082)

test sha256::n1e5::x_4096::step_by_step_generic           ... bench: 358,348,106 ns/iter (+/- 1,015,735)
test sha256::n1e5::x_4096::step_by_step_simple            ... bench: 345,182,582 ns/iter (+/- 803,091)
```

Результат получился достаточно неожиданным. Для монолитной реализации уже добавление по 10 элементов
за один раз даёт скорость сопоставимую с полным перестроением дерева. Однако для обобщённой 
реализации существенное увеличение скорости начинается только ближе к 100 элементам в порции, но
даже при 1000 элементов в порции - скорость находится лишь где-то посередине между простой 
поэлементной вставкой и полным перестроением дерева.

Ещё более радикально эта разница проявляется для других функций. Для siphash не удалось догнать
даже поэлементную вставку, что наводит на мысль об ошибке в реализации и этот вопрос требует
дополнительного исследования.

```
test rust_siphash::n1e5::x_4096::bulk_generic             ... bench:  56,450,389 ns/iter (+/- 3,924,962)
test rust_siphash::n1e5::x_4096::bulk_simple              ... bench:  47,419,303 ns/iter (+/- 5,462,687)

test rust_siphash::n1e5::x_4096::step_bulk::x1e4::generic ... bench:  95,212,283 ns/iter (+/- 1,214,974)
test rust_siphash::n1e5::x_4096::step_bulk::x1e4::simple  ... bench:  53,140,275 ns/iter (+/- 1,435,407)

test rust_siphash::n1e5::x_4096::step_by_step_generic     ... bench:  70,255,058 ns/iter (+/- 978,584)
test rust_siphash::n1e5::x_4096::step_by_step_simple      ... bench:  62,851,766 ns/iter (+/- 4,972,342)

```

(UPD.: Эта ошибка так же найдена и исправлена).


В остальном, нужно отметить, что здесь мы сравнивали разные способы организации хранилища в памяти,
и, хотя в отдельных сценариях можно получить заметный выигрыш от использования монолитной 
реализации, эта разница не столь существенна, чтобы однозначно жертвовать универсальностью.

В свою очередь альтернативные бэкенды, такие как файл на локальной или сетевой ФС, либо СУБД -
будут вносить дополнительные существенные задержки


# Дальнейшее развитие

Хотя текущая реализация предусматривает достаточно универсальный подход и возможность реализации
адаптеров для различных хранилищ данных, нерешёнными остались существенные вопросы, представляющие
интерес для различных применений.

* асинхронное перестроение / проверка дерева с возможностью отслеживания прогресса,
* приостановка / возобновление процесса перестроения / проверки,
* совмещение бэкендов данных и дерева хешей,
* кеширование и буферизация записи для медленных хранилищ,
* поддержка атомарных обновлений / транзакций.

Первые три пункта - относительно просты в реализации и требуют лишь дополнительного времени.
Последние два пункта требуют полноценной проработки.
Последние три пункта - скорее всего потребуют существенного изменения интерфейсов библиотеки.

Также, вероятно, какие-то необходимые функции остались нереализованными, например копирование и
сравнение части дерева, что могло бы быть полезно для систем распределённого обмена контентом,
для быстрого определения расхождений в данных. Хотя что-то подобное несложно выполнить в несколько 
строк кода, поскольку предусмотрен свободный доступ к данным, но реализация этого в API библиотеки
возможно было бы полезным.

